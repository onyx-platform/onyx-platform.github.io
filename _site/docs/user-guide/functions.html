<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Functions</title>
  <meta name="description" content="Distributed, masterless, high performance, fault tolerant data processing
">

  <script>
	  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	  ga('create', 'UA-72807409-1', 'auto');
	  ga('send', 'pageview');
  </script>

  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/lavish-bootstrap.css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/cheat-sheet-style.css">
  <link rel="canonical" href="http://www.onyxplatform.org/docs/user-guide/functions.html">
  <link rel="alternate" type="application/rss+xml" title="Onyx" href="http://www.onyxplatform.org/feed.xml" />
</head>



  <body>
    <header class="site-header">
  <div class="container-fluid">
    <div class="row">
      <div class="col-md-2"></div>
      <div class="col-md-1">
        <h2><a id="nav-title" href="/">Onyx</a></h2>
      </div>
      <div class="col-md-1"></div>
      <div class="col-md-6">
        <ul class="nav nav-pills navbar-right">
          <li class="nav-choice" role="presentation"><a href="/learn">learn</a></li>
          <li class="nav-choice" role="presentation"><a href="/docs">docs</a></li>
          <li class="nav-choice" role="presentation"><a href="/tools">tools</a></li>
          <li class="nav-choice" role="presentation"><a href="/blog">blog</a></li>
          <li class="nav-choice" role="presentation"><a href="https://github.com/onyx-platform/onyx">github</a></li>
          <li class="nav-choice" role="presentation"><a href="/support">support</a></li>
          <li class="nav-choice" role="presentation"><a href="/team">team</a></li>
        </ul>
      </div>
      <div class="col-md-2"></div>
    </div>
  </div>
</header>

    <div class="container-fluid">
  <div class="row">
    <div class="col-md-2 panel page-contents">
      <h4>Contents</h4>
      <ul>
  <li><a href="/docs/cheat-sheet">cheat sheet</a></li>
  <li><a href="/docs/api">api docs</a></li>
  <li>user guide</li>
  <ul>
    
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/aggregation-state-management.html">Aggregation and State</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/apis.html">APIs</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/architecture-low-level-design.html">Architecture</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/backpressure.html">Backpressure</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/concepts.html">Concepts</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/core-async-plugin.html">core.async Plugin</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/deployment.html">Deployment</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/environment.html">Environment</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/examples.html">Examples</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/faq.html">FAQ</a></li>
    
    
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/flow-conditions.html">Flow Conditions</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/functions.html">Functions</a></li>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/information-model.html">Information Model</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/lifecycles.html">Lifecycles</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/logging.html">Logging</a></li>
    
    
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/messaging.html">Messaging</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/monitoring.html">Monitoring</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/peer-config.html">Peer Configuration</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/performance-tuning.html">Performance Tuning</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/plugins.html">Plugins</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/production-check-list.html">Production Checklist</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/scheduling.html">Scheduling</a></li>
    
    
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/subscription.html">Subscription</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/testing-onyx-jobs.html">Testing Onyx Jobs</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/triggers.html">Triggers</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/what-does-it-offer.html">What does it Offer?</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/windowing.html">Windowing</a></li>
    
    
  </ul>
</ul>

    </div>
    <div class="col-md-1"></div>
    <div class="col-md-7 panel">
      <h2 id="functions">Functions</h2>

<p>This section outlines how Onyx programs execute behavior. Onyx uses plain Clojure functions to carry out distributed activity. You have the option of performing grouping and aggregation on each function.</p>

<h4 id="functional-transformation">Functional Transformation</h4>

<p>A Function is a construct that takes a segment as a parameter and outputs a segment or a seq of segments. Functions are meant to literally transform a single unit of data in a functional manner. The following is an example of a function:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">my-inc</span> <span class="p">[{</span><span class="ss">:keys</span> <span class="p">[</span><span class="nv">n</span><span class="p">]</span> <span class="ss">:as</span> <span class="nv">segment</span><span class="p">}]</span>
  <span class="p">(</span><span class="nb">assoc </span><span class="nv">segment</span> <span class="ss">:n</span> <span class="p">(</span><span class="nb">inc </span><span class="nv">n</span><span class="p">)))</span>
</code></pre></div>
<p>Note that you may <em>only</em> pass segments between functions - no other shape of data is allowed.</p>

<p>Example project: <a href="https://github.com/onyx-platform/onyx-examples/tree/0.8.x/filtering">filtering</a></p>

<h4 id="function-parameterization">Function Parameterization</h4>

<p>A function can be parameterized before a job is submitted to Onyx. The segment is always the last argument to the function. There are multiple ways to paramerize a function, and they can be used in combination.</p>

<ul>
<li>Via the catalog <code>:onyx/params</code> entry</li>
</ul>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">catalog</span>
<span class="p">{</span><span class="nv">...</span>
 <span class="ss">:my/param-1</span> <span class="s">&quot;abc&quot;</span>
 <span class="ss">:my/param-2</span> <span class="s">&quot;def&quot;</span>
 <span class="ss">:onyx/params</span> <span class="p">[</span><span class="ss">:my/param-1</span> <span class="ss">:my/param-2</span><span class="p">]</span>
 <span class="nv">...</span><span class="p">}</span>
</code></pre></div>
<p>The function is then invoked with <code>(partial f &quot;abc&quot; &quot;def&quot;)</code>. The order is controlled by the vector of <code>:onyx/params</code>.</p>

<ul>
<li>Via <code>:onyx.core/params</code> in the <code>before-task-start</code> lifecycle hook</li>
</ul>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">before-task-start-hook</span> <span class="p">[</span><span class="nv">event</span> <span class="nv">lifecycle</span><span class="p">]</span>
  <span class="p">{</span><span class="ss">:onyx.core/params</span> <span class="p">[</span><span class="mi">42</span><span class="p">]})</span>
</code></pre></div>
<p>The function is then invoked with <code>(partial f 42)</code>.</p>

<p>Using this approach &quot;hard sets&quot; the parameters list. Other parameters may already exist in <code>onyx.core/params</code>. If you want to retain those parameter, concat them together and return the new value on <code>onyx.core/params</code>.</p>

<ul>
<li>Via the <code>:onyx.peer/fn-params</code> peer configuration</li>
</ul>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">peer-opts</span>
  <span class="p">{</span><span class="nv">...</span>
   <span class="ss">:onyx.peer/fn-params</span> <span class="p">{</span><span class="ss">:my-fn-name</span> <span class="p">[</span><span class="mi">64</span><span class="p">]}})</span>
</code></pre></div>
<p>The function is then invoked with <code>(partial f 64)</code>.</p>

<p>This approach is useful for parameterizing a task regardless of which job it is in. If both <code>onyx.peer/fn-params</code> and <code>:onyx/params</code> are set for the same task, they are concatenated together, with <code>fn-params</code> coming first.</p>

<p>Example projects: <a href="https://github.com/onyx-platform/onyx-examples/tree/0.8.x/parameterized">parameterized</a>, <a href="https://github.com/onyx-platform/onyx-examples/tree/0.8.x/interface-injection">interface-injection</a>, <a href="https://github.com/onyx-platform/onyx-examples/tree/0.8.x/catalog-parameters">catalog-parameters</a></p>

<h4 id="grouping-&amp;-aggregation">Grouping &amp; Aggregation</h4>

<p>Grouping ensures that &quot;like&quot; values are always routed to the same virtual peer, presumably to compute an aggregate. Grouping is specified inside of a catalog entry. There are two ways to group: by key of segment, or by arbitrary function. Grouping by key is a convenience that will reach into each segment and pin all segments with the same key value in the segment together. Grouping functions receive a single segment as input. The output of a grouping function is the value to group on. Grouped functions must set keys <code>:onyx/min-peers</code> and <code>:onyx/flux-policy</code>. See below for a description of these.</p>

<h4 id="group-by-key">Group By Key</h4>

<p>To group by a key or a vector of keys in a segment, use <code>:onyx/group-by-key</code> in the catalog entry:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">{</span><span class="ss">:onyx/name</span> <span class="ss">:sum-balance</span>
 <span class="ss">:onyx/fn</span> <span class="ss">:onyx.peer.kw-grouping-test/sum-balance</span>
 <span class="ss">:onyx/type</span> <span class="ss">:function</span>
 <span class="ss">:onyx/group-by-key</span> <span class="ss">:name</span>
 <span class="ss">:onyx/min-peers</span> <span class="mi">3</span>
 <span class="ss">:onyx/flux-policy</span> <span class="ss">:continue</span>
 <span class="ss">:onyx/batch-size</span> <span class="mi">1000</span><span class="p">}</span>
</code></pre></div>
<h4 id="group-by-function">Group By Function</h4>

<p>To group by an arbitrary function, use <code>:onyx/group-by-fn</code> in the catalog entry:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">{</span><span class="ss">:onyx/name</span> <span class="ss">:sum-balance</span>
 <span class="ss">:onyx/fn</span> <span class="ss">:onyx.peer.fn-grouping-test/sum-balance</span>
 <span class="ss">:onyx/type</span> <span class="ss">:function</span>
 <span class="ss">:onyx/group-by-fn</span> <span class="ss">:onyx.peer.fn-grouping-test/group-by-name</span>
 <span class="ss">:onyx/min-peers</span> <span class="mi">3</span>
 <span class="ss">:onyx/flux-policy</span> <span class="ss">:continue</span>
 <span class="ss">:onyx/batch-size</span> <span class="mi">1000</span><span class="p">}</span>
</code></pre></div>
<h4 id="flux-policies">Flux Policies</h4>

<p>Functions that use the grouping feature are presumably stateful. For this reason, once a job begins, no matter how many peers are added to the cluster, no new peers will be allocated to grouping tasks. If we added more peers after the job began, the hashing algorithm lose its consistency, and stateful operations wouldn&#39;t work correctly.</p>

<p>Given the fact the Onyx will not add more peers to a grouping task after it begins, we introduce a new parameter - <code>:onyx/min-peers</code>. This should be set to an integer that indicates the minimum number of peers that will be allocated to this task before the job can begin. Onyx <em>may</em> schedule more than the minimum number that you set. You can create an upper bound by also using <code>:onyx/max-peers</code> (example project: <a href="https://github.com/onyx-platform/onyx-examples/tree/0.8.x/max-peers">max-peers</a>).</p>

<p>One concern that immediately needs to be handled is addressing what happens if a peer on a grouping task leaves the cluster after the job has begun? Clearly, removing a peer from a grouping task also breaks the consistent hashing algorithm that supports statefulness. The policy that is enforced is configurable, and must be chosen by the developer. We offer two policies, outlined below.</p>

<h5 id="continue-policy">Continue Policy</h5>

<p>When <code>:onyx/flux-policy</code> is set to <code>:continue</code> on a catalog entry, a peer leaving a grouped task will allow the job to continue executing. The hashing algorithm will not be consistent with its previous behavior, but will be consistent from this point forward unless any other peers leave the task. This is desirable for streaming jobs where the data is theoretically infinite.</p>

<h5 id="kill-policy">Kill Policy</h5>

<p>When <code>:onyx/flux-policy</code> is set to <code>:kill</code>, the job is killed and all peers abort execution of the job. Some jobs cannot compute correct answers if there is a shift in the hashing algorithm&#39;s consistency. An example of this is a word count batch job.</p>

<h5 id="recover-policy">Recover Policy</h5>

<p>When <code>:onyx/flux-policy</code> is set to <code>:recover</code>, the job is continues as is if any peers abort execution of the task. If any other peers are available, they will be added to this task to progressively meet the <code>:onyx/min-peers</code> number of peers concurrently working on this task.</p>

<h4 id="bulk-functions">Bulk Functions</h4>

<p>Sometimes you might be able to perform a function more efficiently over a batch of segments rather than processing one segment at a time, such as writing segments to a database in a non-output task. You can receive the entire batch of segments in bulk as an argument to your task by setting <code>:onyx/bulk?</code> to <code>true</code> in your catalog entry for your function. Onyx will <em>ignore</em> the output of your function and pass the same segments that you received downstream. The utility of this feature is that you receive the entire batch in one shot. Onyx ignores your output because it would make it impossible to track which specific messages are children of particular upstream messages - breaking Onyx&#39;s fault tolerance mechanism.</p>

<p>Functions with this key enabled may <em>not</em> be used with flow conditions. These segments are passed to all immediate downstream tasks.</p>

<p>An example catalog entry:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">{</span><span class="ss">:onyx/name</span> <span class="ss">:inc</span>
 <span class="ss">:onyx/fn</span> <span class="ss">:onyx.peer.batch-function-test/my-inc</span>
 <span class="ss">:onyx/type</span> <span class="ss">:function</span>
 <span class="ss">:onyx/bulk?</span> <span class="nv">true</span>
 <span class="ss">:onyx/batch-size</span> <span class="nv">batch-size</span><span class="p">}</span>
</code></pre></div>
<p>And an example catalog function to correspond to this entry:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">my-inc</span> <span class="p">[</span><span class="nv">segments</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">prn </span><span class="nv">segments</span><span class="p">)</span>
  <span class="ss">:ignored-return-value</span><span class="p">)</span>
</code></pre></div>
<p>The default value for this option is <code>false</code>.</p>

<h4 id="leaf-functions">Leaf Functions</h4>

<p>Sometimes you&#39;re going to want a node in your workflow with no outgoing connections that doesn&#39;t perform I/O against a database. You can do this by setting <code>:onyx/type</code> to <code>:output</code>, <code>:onyx/medium</code> to <code>:function</code>, and <code>:onyx/plugin</code> to <code>onyx.peer.function/function</code>. Then you can specify an <code>:onyx/fn</code> pointing to a regular Clojure function. For example:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">{</span><span class="ss">:onyx/name</span> <span class="ss">:leaf-task</span>
 <span class="ss">:onyx/fn</span> <span class="ss">::add-to-results</span>
 <span class="ss">:onyx/plugin</span> <span class="ss">:onyx.peer.function/function</span>
 <span class="ss">:onyx/medium</span> <span class="ss">:function</span>
 <span class="ss">:onyx/type</span> <span class="ss">:output</span>
 <span class="ss">:onyx/batch-size</span> <span class="mi">20</span><span class="p">}</span>
</code></pre></div>
    </div>
  </div>
</div>


    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <small><center>Copyright Â© Distributed Masonry 2016</center></small>
    </div>

  </div>

</footer>

  </body>

</html>
